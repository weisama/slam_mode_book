# 使用STM32读取slam_mode串口数据并解析

## **0.通信协议格式**

**波特率115200，字节格式为8N1**

| 字节序号       | 名称      | 长度     | 说明        | 单位       | 备注        |
| ---------- | ------- | ------ | --------- | -------- | --------- |
| **Byte 0** | 帧头      | 1 byte | 固定 `0xAA` | —        | 起始标志      |
| **Byte 1** | X 高字节   | 1 byte | X 坐标高 8 位 | **cm**   | int16 高字节 |
| **Byte 2** | X 低字节   | 1 byte | X 坐标低 8 位 | **cm**   | int16 低字节 |
| **Byte 3** | Y 高字节   | 1 byte | Y 坐标高 8 位 | **cm**   | int16 高字节 |
| **Byte 4** | Y 低字节   | 1 byte | Y 坐标低 8 位 | **cm**   | int16 低字节 |
| **Byte 5** | Z 高字节   | 1 byte | Z 坐标高 8 位 | **cm**   | int16 高字节 |
| **Byte 6** | Z 低字节   | 1 byte | Z 坐标低 8 位 | **cm**   | int16 低字节 |
| **Byte 7** | roll 高字节 | 1 byte | 翻滚角高字节    | **°（度）** | int16 高字节 |
| **Byte 8** | roll 低字节 | 1 byte | 翻滚角低字节    | **°（度）** | int16 低字节 |
| **Byte 9** | pitch 高字节 | 1 byte | 俯仰角高字节    | **°（度）** | int16 高字节 |
| **Byte 10** | pitch 低字节 | 1 byte | 俯仰角低字节    | **°（度）** | int16 低字节 |
| **Byte 11** | yaw 高字节 | 1 byte | 航向角高字节    | **°（度）** | int16 高字节 |
| **Byte 12** | yaw 低字节 | 1 byte | 航向角低字节    | **°（度）** | int16 低字节 |
| **Byte 13** | 帧尾      | 1 byte | 固定 `0x0A` | —        | 结束标志      |

## 1.例程stm32f103c8t6串口一连接模块

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/e6fce222-0dfe-4da7-b107-a07ed448fb41" width="100%">
    </td>
  </tr>
</table>

## 2.标准库例程

#### 2.1准备一个可运行的标准库点灯工程，或使用[我们提供的标准库工程（点击下载）](https://raw.githubusercontent.com/weisama/slam_mode_book/slam_mode_3d/slam_mode_3d_uart_%E6%A0%87%E5%87%86%E5%BA%93.rar)
#### 2.2编辑代码

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/12bf9f30-65ce-452b-ae25-75c06fc63586" width="70%">
    </td>
  </tr>
</table>

main函数前添加变量声明、串口初始化函数，串口中断解析函数：

<details>
<summary>点击展开查看代码</summary>

```c
uint8_t rx_buf[14];
uint8_t rx_index = 0;

typedef struct
{
    int16_t x;      // cm
    int16_t y;      // cm
    int16_t z;      // cm
    int16_t roll;   // deg
    int16_t pitch;  // deg
    int16_t yaw;    // deg
} PoseData_t;

PoseData_t pose_data;

// 串口初始化
void USART1_Init(uint32_t baud)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);

    // TX PA9 复用推挽输出
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // RX PA10 上拉输入
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // USART 初始化
    USART_InitStructure.USART_BaudRate = baud;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART1, &USART_InitStructure);

    // 使能接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);

    // NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

    // 使能串口
    USART_Cmd(USART1, ENABLE);
}

//串口中断接收并解析
void USART1_IRQHandler(void)
{
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        rx_buf[rx_index] = USART_ReceiveData(USART1);
        rx_index++;

        // 若第一个字节不是帧头，丢弃重新同步
        if (rx_index == 1 && rx_buf[0] != 0xAA)
        {
            rx_index = 0;
        }

        // 收到完整包（14 字节）
        if (rx_index >= 14)
        {
            rx_index = 0;

            if (rx_buf[0] == 0xAA && rx_buf[13] == 0x0A)
            {
                pose_data.x = (int16_t)((rx_buf[1]  << 8) | rx_buf[2]);
                pose_data.y = (int16_t)((rx_buf[3]  << 8) | rx_buf[4]);
                pose_data.z = (int16_t)((rx_buf[5]  << 8) | rx_buf[6]);

                pose_data.roll  = (int16_t)((rx_buf[7]  << 8) | rx_buf[8]);
                pose_data.pitch = (int16_t)((rx_buf[9]  << 8) | rx_buf[10]);
                pose_data.yaw   = (int16_t)((rx_buf[11] << 8) | rx_buf[12]);
            }
        }

        // 清中断标志
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}
```

</details>

main函数中添加串口初始化：

```
USART1_Init(115200);     // 串口初始化
```

#### 2.3运行代码

编辑完代码，编译烧录进stm32f103c8t6，然后进入debug模式。

pose_data用于保存解析后的数据，双击左键选中后右键添加到窗口1。

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/63f67575-d2f1-46d6-8bed-a53dacc2f2b9" width="100%">
    </td>
  </tr>
</table>

左上角按键运行代码。

在窗口一右键pose_data设置10进制显示，展开pose_data可观察到解析出的数据：

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/ce0446b4-2ab8-44f5-8884-63f47afced9e" width="100%">
    </td>
  </tr>
</table>

**接收到的数据xyz单位为厘米，yaw单位为度**

**坐标轴遵循ENU，上电时以机器人朝向建立坐标轴，红色坐标轴（机器人前方）为X+方向，绿色坐标轴（机器人左方）为Y+方向，蓝色坐标轴（机器人上方）为Z+方向**

**姿态角yaw：模块启动时以X+为0度，向右顺时针转动范围0到-180度，向左逆时针转动范围0到180度；pitch，roll同理**

---

## 3.hal库例程

#### 3.1准备一个可运行的hal库点灯工程，或使用[我们提供的hal库工程（点击下载）](https://raw.githubusercontent.com/weisama/slam_mode_book/slam_mode_3d/slam_mode_3d_uart_hal%E5%BA%93.rar)

#### 3.2编辑工程

STM32CubeMX设置串口PA9和PA10用于串口通信：

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/f5a50489-21e3-47d6-9f19-13b57d369049" width="100%">
    </td>
  </tr>
</table>

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/97242ff1-e3c1-46dc-8086-b271f72bbf26" width="70%">
    </td>
  </tr>
</table>

#### 3.3编辑代码

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/5e4b3dd4-cb88-474c-ac7a-94031e245df6" width="70%">
    </td>
  </tr>
</table>

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/a068934f-7902-4109-a397-4a826777e0c7" width="70%">
    </td>
  </tr>
</table>

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/cc6939a8-2ea9-4a08-a68f-0cadb9f58398" width="70%">
    </td>
  </tr>
</table>

main函数前添加变量声明：

```
uint8_t rx_buf[14];
uint8_t rx_index = 0;

typedef struct
{
    int16_t x;      // cm
    int16_t y;      // cm
    int16_t z;      // cm
    int16_t roll;   // deg
    int16_t pitch;  // deg
    int16_t yaw;    // deg
} PoseData_t;

PoseData_t pose_data;
```

main函数中添加串口初始化：

```
HAL_UART_Receive_IT(&huart1, &rx_buf[rx_index], 1);
```

main函数后添加串口中断解析函数：

```
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        rx_index++;

        // 第一个字节不是帧头，立即丢弃
        if (rx_index == 1 && rx_buf[0] != 0xAA)
        {
            rx_index = 0;
        }

        // 收到完整一帧（14 字节）
        if (rx_index >= 14)
        {
            rx_index = 0;

            // 校验帧头和帧尾
            if (rx_buf[0] == 0xAA && rx_buf[13] == 0x0A)
            {
                cnt++;

                pose_data.x = (int16_t)((rx_buf[1]  << 8) | rx_buf[2]);
                pose_data.y = (int16_t)((rx_buf[3]  << 8) | rx_buf[4]);
                pose_data.z = (int16_t)((rx_buf[5]  << 8) | rx_buf[6]);

                pose_data.roll  = (int16_t)((rx_buf[7]  << 8) | rx_buf[8]);
                pose_data.pitch = (int16_t)((rx_buf[9]  << 8) | rx_buf[10]);
                pose_data.yaw   = (int16_t)((rx_buf[11] << 8) | rx_buf[12]);
            }
        }

        // 继续接收下一个字节
        HAL_UART_Receive_IT(&huart1, &rx_buf[rx_index], 1);
    }
}
```

#### 3.4运行代码

编辑完代码，编译并烧录，然后进入debug模式。

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/346eaa2a-ade4-4f5e-8804-137b137a167e" width="100%">
    </td>
  </tr>
</table>

在窗口一右键pose_data设置10进制显示，可以看到解析的数据：

<table>
  <tr>
    <td style="border: 10px solid black; padding: 0;">
      <img src="https://github.com/user-attachments/assets/86f4aedf-7a51-4151-b29e-ce5d28e21a77" width="100%">
    </td>
  </tr>
</table>

**接收到的数据xyz单位为厘米，yaw单位为度**

**坐标轴遵循ENU，上电时以机器人朝向建立坐标轴，红色坐标轴（机器人前方）为X+方向，绿色坐标轴（机器人左方）为Y+方向，蓝色坐标轴（机器人上方）为Z+方向**

**姿态角yaw：模块启动时以X+为0度，向右顺时针转动范围0到-180度，向左逆时针转动范围0到180度；pitch，roll同理**
